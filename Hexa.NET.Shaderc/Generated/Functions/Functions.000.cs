// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.Shaderc
{
	public unsafe partial class Shaderc
	{
		/// <summary>
		/// Returns a shaderc_compiler_t that can be used to compile modules.<br/>
		/// A return of NULL indicates that there was an error initializing the compiler.<br/>
		/// Any function operating on shaderc_compiler_t must offer the basic<br/>
		/// thread-safety guarantee.<br/>
		/// [http://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/]<br/>
		/// That is: concurrent invocation of these functions on DIFFERENT objects needs<br/>
		/// no synchronization; concurrent invocation of these functions on the SAME<br/>
		/// object requires synchronization IF AND ONLY IF some of them take a non-const<br/>
		/// argument.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ShadercCompiler CompilerInitializeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompiler>)funcTable[0])();
			#else
			return (ShadercCompiler)((delegate* unmanaged[Cdecl]<ShadercCompiler>)funcTable[0])();
			#endif
		}

		/// <summary>
		/// Returns a shaderc_compiler_t that can be used to compile modules.<br/>
		/// A return of NULL indicates that there was an error initializing the compiler.<br/>
		/// Any function operating on shaderc_compiler_t must offer the basic<br/>
		/// thread-safety guarantee.<br/>
		/// [http://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/]<br/>
		/// That is: concurrent invocation of these functions on DIFFERENT objects needs<br/>
		/// no synchronization; concurrent invocation of these functions on the SAME<br/>
		/// object requires synchronization IF AND ONLY IF some of them take a non-const<br/>
		/// argument.<br/>
		/// </summary>
		public static ShadercCompiler CompilerInitialize()
		{
			ShadercCompiler ret = CompilerInitializeNative();
			return ret;
		}

		/// <summary>
		/// Releases the resources held by the shaderc_compiler_t.<br/>
		/// After this call it is invalid to make any future calls to functions<br/>
		/// involving this shaderc_compiler_t.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerReleaseNative(ShadercCompiler unknown0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompiler, void>)funcTable[1])(unknown0);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompiler, void>)funcTable[1])(unknown0);
			#endif
		}

		/// <summary>
		/// Releases the resources held by the shaderc_compiler_t.<br/>
		/// After this call it is invalid to make any future calls to functions<br/>
		/// involving this shaderc_compiler_t.<br/>
		/// </summary>
		public static void CompilerRelease(ShadercCompiler unknown0)
		{
			CompilerReleaseNative(unknown0);
		}

		/// <summary>
		/// Returns a default-initialized shaderc_compile_options_t that can be used<br/>
		/// to modify the functionality of a compiled module.<br/>
		/// A return of NULL indicates that there was an error initializing the options.<br/>
		/// Any function operating on shaderc_compile_options_t must offer the<br/>
		/// basic thread-safety guarantee.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ShadercCompileOptions CompileOptionsInitializeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompileOptions>)funcTable[2])();
			#else
			return (ShadercCompileOptions)((delegate* unmanaged[Cdecl]<ShadercCompileOptions>)funcTable[2])();
			#endif
		}

		/// <summary>
		/// Returns a default-initialized shaderc_compile_options_t that can be used<br/>
		/// to modify the functionality of a compiled module.<br/>
		/// A return of NULL indicates that there was an error initializing the options.<br/>
		/// Any function operating on shaderc_compile_options_t must offer the<br/>
		/// basic thread-safety guarantee.<br/>
		/// </summary>
		public static ShadercCompileOptions CompileOptionsInitialize()
		{
			ShadercCompileOptions ret = CompileOptionsInitializeNative();
			return ret;
		}

		/// <summary>
		/// Returns a copy of the given shaderc_compile_options_t.<br/>
		/// If NULL is passed as the parameter the call is the same as<br/>
		/// shaderc_compile_options_init.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ShadercCompileOptions CompileOptionsCloneNative(ShadercCompileOptions options)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercCompileOptions>)funcTable[3])(options);
			#else
			return (ShadercCompileOptions)((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercCompileOptions>)funcTable[3])(options);
			#endif
		}

		/// <summary>
		/// Returns a copy of the given shaderc_compile_options_t.<br/>
		/// If NULL is passed as the parameter the call is the same as<br/>
		/// shaderc_compile_options_init.<br/>
		/// </summary>
		public static ShadercCompileOptions CompileOptionsClone(ShadercCompileOptions options)
		{
			ShadercCompileOptions ret = CompileOptionsCloneNative(options);
			return ret;
		}

		/// <summary>
		/// Releases the compilation options. It is invalid to use the given<br/>
		/// shaderc_compile_options_t object in any future calls. It is safe to pass<br/>
		/// NULL to this function, and doing such will have no effect.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsReleaseNative(ShadercCompileOptions options)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, void>)funcTable[4])(options);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, void>)funcTable[4])(options);
			#endif
		}

		/// <summary>
		/// Releases the compilation options. It is invalid to use the given<br/>
		/// shaderc_compile_options_t object in any future calls. It is safe to pass<br/>
		/// NULL to this function, and doing such will have no effect.<br/>
		/// </summary>
		public static void CompileOptionsRelease(ShadercCompileOptions options)
		{
			CompileOptionsReleaseNative(options);
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsAddMacroDefinitionNative(ShadercCompileOptions options, byte* name, nuint nameLength, byte* value, nuint valueLength)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte*, nuint, byte*, nuint, void>)funcTable[5])(options, name, nameLength, value, valueLength);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, nint, nuint, nint, nuint, void>)funcTable[5])(options, (nint)name, nameLength, (nint)value, valueLength);
			#endif
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		public static void CompileOptionsAddMacroDefinition(ShadercCompileOptions options, byte* name, nuint nameLength, byte* value, nuint valueLength)
		{
			CompileOptionsAddMacroDefinitionNative(options, name, nameLength, value, valueLength);
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		public static void CompileOptionsAddMacroDefinition(ShadercCompileOptions options, ref byte name, nuint nameLength, byte* value, nuint valueLength)
		{
			fixed (byte* pname = &name)
			{
				CompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, value, valueLength);
			}
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		public static void CompileOptionsAddMacroDefinition(ShadercCompileOptions options, ReadOnlySpan<byte> name, nuint nameLength, byte* value, nuint valueLength)
		{
			fixed (byte* pname = name)
			{
				CompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, value, valueLength);
			}
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		public static void CompileOptionsAddMacroDefinition(ShadercCompileOptions options, string name, nuint nameLength, byte* value, nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, value, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		public static void CompileOptionsAddMacroDefinition(ShadercCompileOptions options, byte* name, nuint nameLength, ref byte value, nuint valueLength)
		{
			fixed (byte* pvalue = &value)
			{
				CompileOptionsAddMacroDefinitionNative(options, name, nameLength, (byte*)pvalue, valueLength);
			}
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		public static void CompileOptionsAddMacroDefinition(ShadercCompileOptions options, byte* name, nuint nameLength, ReadOnlySpan<byte> value, nuint valueLength)
		{
			fixed (byte* pvalue = value)
			{
				CompileOptionsAddMacroDefinitionNative(options, name, nameLength, (byte*)pvalue, valueLength);
			}
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		public static void CompileOptionsAddMacroDefinition(ShadercCompileOptions options, byte* name, nuint nameLength, string value, nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompileOptionsAddMacroDefinitionNative(options, name, nameLength, pStr0, valueLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		public static void CompileOptionsAddMacroDefinition(ShadercCompileOptions options, ref byte name, nuint nameLength, ref byte value, nuint valueLength)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					CompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, (byte*)pvalue, valueLength);
				}
			}
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		public static void CompileOptionsAddMacroDefinition(ShadercCompileOptions options, ReadOnlySpan<byte> name, nuint nameLength, ReadOnlySpan<byte> value, nuint valueLength)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					CompileOptionsAddMacroDefinitionNative(options, (byte*)pname, nameLength, (byte*)pvalue, valueLength);
				}
			}
		}

		/// <summary>
		/// Adds a predefined macro to the compilation options. This has the same<br/>
		/// effect as passing -Dname=value to the command-line compiler.  If value<br/>
		/// is NULL, it has the same effect as passing -Dname to the command-line<br/>
		/// compiler. If a macro definition with the same name has previously been<br/>
		/// added, the value is replaced with the new value. The macro name and<br/>
		/// value are passed in with char pointers, which point to their data, and<br/>
		/// the lengths of their data. The strings that the name and value pointers<br/>
		/// point to must remain valid for the duration of the call, but can be<br/>
		/// modified or deleted after this function has returned. In case of adding<br/>
		/// a valueless macro, the value argument should be a null pointer or the<br/>
		/// value_length should be 0u.<br/>
		/// </summary>
		public static void CompileOptionsAddMacroDefinition(ShadercCompileOptions options, string name, nuint nameLength, string value, nuint valueLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CompileOptionsAddMacroDefinitionNative(options, pStr0, nameLength, pStr1, valueLength);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets the source language.  The default is GLSL.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetSourceLanguageNative(ShadercCompileOptions options, ShadercSourceLanguage lang)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercSourceLanguage, void>)funcTable[6])(options, lang);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercSourceLanguage, void>)funcTable[6])(options, lang);
			#endif
		}

		/// <summary>
		/// Sets the source language.  The default is GLSL.<br/>
		/// </summary>
		public static void CompileOptionsSetSourceLanguage(ShadercCompileOptions options, ShadercSourceLanguage lang)
		{
			CompileOptionsSetSourceLanguageNative(options, lang);
		}

		/// <summary>
		/// Sets the compiler mode to generate debug information in the output.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetGenerateDebugInfoNative(ShadercCompileOptions options)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, void>)funcTable[7])(options);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, void>)funcTable[7])(options);
			#endif
		}

		/// <summary>
		/// Sets the compiler mode to generate debug information in the output.<br/>
		/// </summary>
		public static void CompileOptionsSetGenerateDebugInfo(ShadercCompileOptions options)
		{
			CompileOptionsSetGenerateDebugInfoNative(options);
		}

		/// <summary>
		/// Sets the compiler optimization level to the given level. Only the last one<br/>
		/// takes effect if multiple calls of this function exist.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetOptimizationLevelNative(ShadercCompileOptions options, ShadercOptimizationLevel level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercOptimizationLevel, void>)funcTable[8])(options, level);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercOptimizationLevel, void>)funcTable[8])(options, level);
			#endif
		}

		/// <summary>
		/// Sets the compiler optimization level to the given level. Only the last one<br/>
		/// takes effect if multiple calls of this function exist.<br/>
		/// </summary>
		public static void CompileOptionsSetOptimizationLevel(ShadercCompileOptions options, ShadercOptimizationLevel level)
		{
			CompileOptionsSetOptimizationLevelNative(options, level);
		}

		/// <summary>
		/// Forces the GLSL language version and profile to a given pair. The version<br/>
		/// number is the same as would appear in the #version annotation in the source.<br/>
		/// Version and profile specified here overrides the #version annotation in the<br/>
		/// source. Use profile: 'shaderc_profile_none' for GLSL versions that do not<br/>
		/// define profiles, e.g. versions below 150.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetForcedVersionProfileNative(ShadercCompileOptions options, int version, ShadercProfile profile)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, int, ShadercProfile, void>)funcTable[9])(options, version, profile);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, int, ShadercProfile, void>)funcTable[9])(options, version, profile);
			#endif
		}

		/// <summary>
		/// Forces the GLSL language version and profile to a given pair. The version<br/>
		/// number is the same as would appear in the #version annotation in the source.<br/>
		/// Version and profile specified here overrides the #version annotation in the<br/>
		/// source. Use profile: 'shaderc_profile_none' for GLSL versions that do not<br/>
		/// define profiles, e.g. versions below 150.<br/>
		/// </summary>
		public static void CompileOptionsSetForcedVersionProfile(ShadercCompileOptions options, int version, ShadercProfile profile)
		{
			CompileOptionsSetForcedVersionProfileNative(options, version, profile);
		}

		/// <summary>
		/// Sets includer callback functions.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetIncludeCallbacksNative(ShadercCompileOptions options, ShadercIncludeResolveFn resolver, ShadercIncludeResultReleaseFn resultReleaser, void* userData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, delegate*<void*, byte*, int, byte*, nuint, ShadercIncludeResult*>, delegate*<void*, ShadercIncludeResult*, void>, void*, void>)funcTable[10])(options, (delegate*<void*, byte*, int, byte*, nuint, ShadercIncludeResult*>)Utils.GetFunctionPointerForDelegate(resolver), (delegate*<void*, ShadercIncludeResult*, void>)Utils.GetFunctionPointerForDelegate(resultReleaser), userData);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, nint, nint, nint, void>)funcTable[10])(options, (nint)Utils.GetFunctionPointerForDelegate(resolver), (nint)Utils.GetFunctionPointerForDelegate(resultReleaser), (nint)userData);
			#endif
		}

		/// <summary>
		/// Sets includer callback functions.<br/>
		/// </summary>
		public static void CompileOptionsSetIncludeCallbacks(ShadercCompileOptions options, ShadercIncludeResolveFn resolver, ShadercIncludeResultReleaseFn resultReleaser, void* userData)
		{
			CompileOptionsSetIncludeCallbacksNative(options, resolver, resultReleaser, userData);
		}

		/// <summary>
		/// Sets the compiler mode to suppress warnings, overriding warnings-as-errors<br/>
		/// mode. When both suppress-warnings and warnings-as-errors modes are<br/>
		/// turned on, warning messages will be inhibited, and will not be emitted<br/>
		/// as error messages.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetSuppressWarningsNative(ShadercCompileOptions options)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, void>)funcTable[11])(options);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, void>)funcTable[11])(options);
			#endif
		}

		/// <summary>
		/// Sets the compiler mode to suppress warnings, overriding warnings-as-errors<br/>
		/// mode. When both suppress-warnings and warnings-as-errors modes are<br/>
		/// turned on, warning messages will be inhibited, and will not be emitted<br/>
		/// as error messages.<br/>
		/// </summary>
		public static void CompileOptionsSetSuppressWarnings(ShadercCompileOptions options)
		{
			CompileOptionsSetSuppressWarningsNative(options);
		}

		/// <summary>
		/// Sets the target shader environment, affecting which warnings or errors will<br/>
		/// be issued.  The version will be for distinguishing between different versions<br/>
		/// of the target environment.  The version value should be either 0 or<br/>
		/// a value listed in shaderc_env_version.  The 0 value maps to Vulkan 1.0 if<br/>
		/// |target| is Vulkan, and it maps to OpenGL 4.5 if |target| is OpenGL.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetTargetEnvNative(ShadercCompileOptions options, ShadercTargetEnv target, uint version)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercTargetEnv, uint, void>)funcTable[12])(options, target, version);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercTargetEnv, uint, void>)funcTable[12])(options, target, version);
			#endif
		}

		/// <summary>
		/// Sets the target shader environment, affecting which warnings or errors will<br/>
		/// be issued.  The version will be for distinguishing between different versions<br/>
		/// of the target environment.  The version value should be either 0 or<br/>
		/// a value listed in shaderc_env_version.  The 0 value maps to Vulkan 1.0 if<br/>
		/// |target| is Vulkan, and it maps to OpenGL 4.5 if |target| is OpenGL.<br/>
		/// </summary>
		public static void CompileOptionsSetTargetEnv(ShadercCompileOptions options, ShadercTargetEnv target, uint version)
		{
			CompileOptionsSetTargetEnvNative(options, target, version);
		}

		/// <summary>
		/// Sets the target SPIR-V version. The generated module will use this version<br/>
		/// of SPIR-V.  Each target environment determines what versions of SPIR-V<br/>
		/// it can consume.  Defaults to the highest version of SPIR-V 1.0 which is<br/>
		/// required to be supported by the target environment.  E.g. Default to SPIR-V<br/>
		/// 1.0 for Vulkan 1.0 and SPIR-V 1.3 for Vulkan 1.1.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetTargetSpirvNative(ShadercCompileOptions options, ShadercSpirvVersion version)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercSpirvVersion, void>)funcTable[13])(options, version);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercSpirvVersion, void>)funcTable[13])(options, version);
			#endif
		}

		/// <summary>
		/// Sets the target SPIR-V version. The generated module will use this version<br/>
		/// of SPIR-V.  Each target environment determines what versions of SPIR-V<br/>
		/// it can consume.  Defaults to the highest version of SPIR-V 1.0 which is<br/>
		/// required to be supported by the target environment.  E.g. Default to SPIR-V<br/>
		/// 1.0 for Vulkan 1.0 and SPIR-V 1.3 for Vulkan 1.1.<br/>
		/// </summary>
		public static void CompileOptionsSetTargetSpirv(ShadercCompileOptions options, ShadercSpirvVersion version)
		{
			CompileOptionsSetTargetSpirvNative(options, version);
		}

		/// <summary>
		/// Sets the compiler mode to treat all warnings as errors. Note the<br/>
		/// suppress-warnings mode overrides this option, i.e. if both<br/>
		/// warning-as-errors and suppress-warnings modes are set, warnings will not<br/>
		/// be emitted as error messages.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetWarningsAsErrorsNative(ShadercCompileOptions options)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, void>)funcTable[14])(options);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, void>)funcTable[14])(options);
			#endif
		}

		/// <summary>
		/// Sets the compiler mode to treat all warnings as errors. Note the<br/>
		/// suppress-warnings mode overrides this option, i.e. if both<br/>
		/// warning-as-errors and suppress-warnings modes are set, warnings will not<br/>
		/// be emitted as error messages.<br/>
		/// </summary>
		public static void CompileOptionsSetWarningsAsErrors(ShadercCompileOptions options)
		{
			CompileOptionsSetWarningsAsErrorsNative(options);
		}

		/// <summary>
		/// Sets a resource limit.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetLimitNative(ShadercCompileOptions options, ShadercLimit limit, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercLimit, int, void>)funcTable[15])(options, limit, value);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercLimit, int, void>)funcTable[15])(options, limit, value);
			#endif
		}

		/// <summary>
		/// Sets a resource limit.<br/>
		/// </summary>
		public static void CompileOptionsSetLimit(ShadercCompileOptions options, ShadercLimit limit, int value)
		{
			CompileOptionsSetLimitNative(options, limit, value);
		}

		/// <summary>
		/// Sets whether the compiler should automatically assign bindings to uniforms<br/>
		/// that aren't already explicitly bound in the shader source.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetAutoBindUniformsNative(ShadercCompileOptions options, byte autoBind)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[16])(options, autoBind);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[16])(options, autoBind);
			#endif
		}

		/// <summary>
		/// Sets whether the compiler should automatically assign bindings to uniforms<br/>
		/// that aren't already explicitly bound in the shader source.<br/>
		/// </summary>
		public static void CompileOptionsSetAutoBindUniforms(ShadercCompileOptions options, bool autoBind)
		{
			CompileOptionsSetAutoBindUniformsNative(options, autoBind ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets whether the compiler should automatically remove sampler variables<br/>
		/// and convert image variables to combined image-sampler variables.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetAutoCombinedImageSamplerNative(ShadercCompileOptions options, byte upgrade)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[17])(options, upgrade);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[17])(options, upgrade);
			#endif
		}

		/// <summary>
		/// Sets whether the compiler should automatically remove sampler variables<br/>
		/// and convert image variables to combined image-sampler variables.<br/>
		/// </summary>
		public static void CompileOptionsSetAutoCombinedImageSampler(ShadercCompileOptions options, bool upgrade)
		{
			CompileOptionsSetAutoCombinedImageSamplerNative(options, upgrade ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets whether the compiler should use HLSL IO mapping rules for bindings.<br/>
		/// Defaults to false.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetHlslIoMappingNative(ShadercCompileOptions options, byte hlslIomap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[18])(options, hlslIomap);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[18])(options, hlslIomap);
			#endif
		}

		/// <summary>
		/// Sets whether the compiler should use HLSL IO mapping rules for bindings.<br/>
		/// Defaults to false.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslIoMapping(ShadercCompileOptions options, bool hlslIomap)
		{
			CompileOptionsSetHlslIoMappingNative(options, hlslIomap ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets whether the compiler should determine block member offsets using HLSL<br/>
		/// packing rules instead of standard GLSL rules.  Defaults to false.  Only<br/>
		/// affects GLSL compilation.  HLSL rules are always used when compiling HLSL.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetHlslOffsetsNative(ShadercCompileOptions options, byte hlslOffsets)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[19])(options, hlslOffsets);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[19])(options, hlslOffsets);
			#endif
		}

		/// <summary>
		/// Sets whether the compiler should determine block member offsets using HLSL<br/>
		/// packing rules instead of standard GLSL rules.  Defaults to false.  Only<br/>
		/// affects GLSL compilation.  HLSL rules are always used when compiling HLSL.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslOffsets(ShadercCompileOptions options, bool hlslOffsets)
		{
			CompileOptionsSetHlslOffsetsNative(options, hlslOffsets ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets the base binding number used for for a uniform resource type when<br/>
		/// automatically assigning bindings.  For GLSL compilation, sets the lowest<br/>
		/// automatically assigned number.  For HLSL compilation, the regsiter number<br/>
		/// assigned to the resource is added to this specified base.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetBindingBaseNative(ShadercCompileOptions options, ShadercUniformKind kind, uint baseValue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercUniformKind, uint, void>)funcTable[20])(options, kind, baseValue);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercUniformKind, uint, void>)funcTable[20])(options, kind, baseValue);
			#endif
		}

		/// <summary>
		/// Sets the base binding number used for for a uniform resource type when<br/>
		/// automatically assigning bindings.  For GLSL compilation, sets the lowest<br/>
		/// automatically assigned number.  For HLSL compilation, the regsiter number<br/>
		/// assigned to the resource is added to this specified base.<br/>
		/// </summary>
		public static void CompileOptionsSetBindingBase(ShadercCompileOptions options, ShadercUniformKind kind, uint baseValue)
		{
			CompileOptionsSetBindingBaseNative(options, kind, baseValue);
		}

		/// <summary>
		/// Like shaderc_compile_options_set_binding_base, but only takes effect when<br/>
		/// compiling a given shader stage.  The stage is assumed to be one of vertex,<br/>
		/// fragment, tessellation evaluation, tesselation control, geometry, or compute.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetBindingBaseForStageNative(ShadercCompileOptions options, ShadercShaderKind shaderKind, ShadercUniformKind kind, uint baseValue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercShaderKind, ShadercUniformKind, uint, void>)funcTable[21])(options, shaderKind, kind, baseValue);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercShaderKind, ShadercUniformKind, uint, void>)funcTable[21])(options, shaderKind, kind, baseValue);
			#endif
		}

		/// <summary>
		/// Like shaderc_compile_options_set_binding_base, but only takes effect when<br/>
		/// compiling a given shader stage.  The stage is assumed to be one of vertex,<br/>
		/// fragment, tessellation evaluation, tesselation control, geometry, or compute.<br/>
		/// </summary>
		public static void CompileOptionsSetBindingBaseForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, ShadercUniformKind kind, uint baseValue)
		{
			CompileOptionsSetBindingBaseForStageNative(options, shaderKind, kind, baseValue);
		}

		/// <summary>
		/// Sets whether the compiler should preserve all bindings, even when those<br/>
		/// bindings are not used.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetPreserveBindingsNative(ShadercCompileOptions options, byte preserveBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[22])(options, preserveBindings);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[22])(options, preserveBindings);
			#endif
		}

		/// <summary>
		/// Sets whether the compiler should preserve all bindings, even when those<br/>
		/// bindings are not used.<br/>
		/// </summary>
		public static void CompileOptionsSetPreserveBindings(ShadercCompileOptions options, bool preserveBindings)
		{
			CompileOptionsSetPreserveBindingsNative(options, preserveBindings ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets whether the compiler should automatically assign locations to<br/>
		/// uniform variables that don't have explicit locations in the shader source.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetAutoMapLocationsNative(ShadercCompileOptions options, byte autoMap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[23])(options, autoMap);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[23])(options, autoMap);
			#endif
		}

		/// <summary>
		/// Sets whether the compiler should automatically assign locations to<br/>
		/// uniform variables that don't have explicit locations in the shader source.<br/>
		/// </summary>
		public static void CompileOptionsSetAutoMapLocations(ShadercCompileOptions options, bool autoMap)
		{
			CompileOptionsSetAutoMapLocationsNative(options, autoMap ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetHlslRegisterSetAndBindingForStageNative(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, byte* set, byte* binding)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercShaderKind, byte*, byte*, byte*, void>)funcTable[24])(options, shaderKind, reg, set, binding);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, ShadercShaderKind, nint, nint, nint, void>)funcTable[24])(options, shaderKind, (nint)reg, (nint)set, (nint)binding);
			#endif
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, byte* set, byte* binding)
		{
			CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, set, binding);
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, ref byte reg, byte* set, byte* binding)
		{
			fixed (byte* preg = &reg)
			{
				CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, set, binding);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, ReadOnlySpan<byte> reg, byte* set, byte* binding)
		{
			fixed (byte* preg = reg)
			{
				CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, set, binding);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, string reg, byte* set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, set, binding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, ref byte set, byte* binding)
		{
			fixed (byte* pset = &set)
			{
				CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, (byte*)pset, binding);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, ReadOnlySpan<byte> set, byte* binding)
		{
			fixed (byte* pset = set)
			{
				CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, (byte*)pset, binding);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, string set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (set != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(set);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(set, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, pStr0, binding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, ref byte reg, ref byte set, byte* binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pset = &set)
				{
					CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, (byte*)pset, binding);
				}
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, ReadOnlySpan<byte> reg, ReadOnlySpan<byte> set, byte* binding)
		{
			fixed (byte* preg = reg)
			{
				fixed (byte* pset = set)
				{
					CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, (byte*)pset, binding);
				}
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, string reg, string set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (set != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(set);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(set, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, pStr1, binding);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, byte* set, ref byte binding)
		{
			fixed (byte* pbinding = &binding)
			{
				CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, set, (byte*)pbinding);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, byte* set, ReadOnlySpan<byte> binding)
		{
			fixed (byte* pbinding = binding)
			{
				CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, set, (byte*)pbinding);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, byte* set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (binding != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(binding);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(binding, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, set, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, ref byte reg, byte* set, ref byte binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pbinding = &binding)
				{
					CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, set, (byte*)pbinding);
				}
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, ReadOnlySpan<byte> reg, byte* set, ReadOnlySpan<byte> binding)
		{
			fixed (byte* preg = reg)
			{
				fixed (byte* pbinding = binding)
				{
					CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, set, (byte*)pbinding);
				}
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, string reg, byte* set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (binding != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(binding);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(binding, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, set, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, ref byte set, ref byte binding)
		{
			fixed (byte* pset = &set)
			{
				fixed (byte* pbinding = &binding)
				{
					CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, (byte*)pset, (byte*)pbinding);
				}
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, ReadOnlySpan<byte> set, ReadOnlySpan<byte> binding)
		{
			fixed (byte* pset = set)
			{
				fixed (byte* pbinding = binding)
				{
					CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, (byte*)pset, (byte*)pbinding);
				}
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, byte* reg, string set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (set != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(set);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(set, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (binding != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(binding);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(binding, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, reg, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, ref byte reg, ref byte set, ref byte binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pset = &set)
				{
					fixed (byte* pbinding = &binding)
					{
						CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, (byte*)pset, (byte*)pbinding);
					}
				}
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, ReadOnlySpan<byte> reg, ReadOnlySpan<byte> set, ReadOnlySpan<byte> binding)
		{
			fixed (byte* preg = reg)
			{
				fixed (byte* pset = set)
				{
					fixed (byte* pbinding = binding)
					{
						CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, (byte*)preg, (byte*)pset, (byte*)pbinding);
					}
				}
			}
		}

		/// <summary>
		/// Sets a descriptor set and binding for an HLSL register in the given stage.<br/>
		/// This method keeps a copy of the string data.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBindingForStage(ShadercCompileOptions options, ShadercShaderKind shaderKind, string reg, string set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (set != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(set);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(set, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (binding != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(binding);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(binding, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingForStageNative(options, shaderKind, pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetHlslRegisterSetAndBindingNative(ShadercCompileOptions options, byte* reg, byte* set, byte* binding)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte*, byte*, byte*, void>)funcTable[25])(options, reg, set, binding);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, nint, nint, nint, void>)funcTable[25])(options, (nint)reg, (nint)set, (nint)binding);
			#endif
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, byte* reg, byte* set, byte* binding)
		{
			CompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, set, binding);
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, ref byte reg, byte* set, byte* binding)
		{
			fixed (byte* preg = &reg)
			{
				CompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, set, binding);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, ReadOnlySpan<byte> reg, byte* set, byte* binding)
		{
			fixed (byte* preg = reg)
			{
				CompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, set, binding);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, string reg, byte* set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingNative(options, pStr0, set, binding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, byte* reg, ref byte set, byte* binding)
		{
			fixed (byte* pset = &set)
			{
				CompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, (byte*)pset, binding);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, byte* reg, ReadOnlySpan<byte> set, byte* binding)
		{
			fixed (byte* pset = set)
			{
				CompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, (byte*)pset, binding);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, byte* reg, string set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (set != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(set);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(set, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, pStr0, binding);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, ref byte reg, ref byte set, byte* binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pset = &set)
				{
					CompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, (byte*)pset, binding);
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, ReadOnlySpan<byte> reg, ReadOnlySpan<byte> set, byte* binding)
		{
			fixed (byte* preg = reg)
			{
				fixed (byte* pset = set)
				{
					CompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, (byte*)pset, binding);
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, string reg, string set, byte* binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (set != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(set);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(set, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingNative(options, pStr0, pStr1, binding);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, byte* reg, byte* set, ref byte binding)
		{
			fixed (byte* pbinding = &binding)
			{
				CompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, set, (byte*)pbinding);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, byte* reg, byte* set, ReadOnlySpan<byte> binding)
		{
			fixed (byte* pbinding = binding)
			{
				CompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, set, (byte*)pbinding);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, byte* reg, byte* set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (binding != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(binding);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(binding, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, set, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, ref byte reg, byte* set, ref byte binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pbinding = &binding)
				{
					CompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, set, (byte*)pbinding);
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, ReadOnlySpan<byte> reg, byte* set, ReadOnlySpan<byte> binding)
		{
			fixed (byte* preg = reg)
			{
				fixed (byte* pbinding = binding)
				{
					CompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, set, (byte*)pbinding);
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, string reg, byte* set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (binding != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(binding);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(binding, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingNative(options, pStr0, set, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, byte* reg, ref byte set, ref byte binding)
		{
			fixed (byte* pset = &set)
			{
				fixed (byte* pbinding = &binding)
				{
					CompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, (byte*)pset, (byte*)pbinding);
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, byte* reg, ReadOnlySpan<byte> set, ReadOnlySpan<byte> binding)
		{
			fixed (byte* pset = set)
			{
				fixed (byte* pbinding = binding)
				{
					CompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, (byte*)pset, (byte*)pbinding);
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, byte* reg, string set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (set != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(set);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(set, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (binding != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(binding);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(binding, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingNative(options, reg, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, ref byte reg, ref byte set, ref byte binding)
		{
			fixed (byte* preg = &reg)
			{
				fixed (byte* pset = &set)
				{
					fixed (byte* pbinding = &binding)
					{
						CompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, (byte*)pset, (byte*)pbinding);
					}
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, ReadOnlySpan<byte> reg, ReadOnlySpan<byte> set, ReadOnlySpan<byte> binding)
		{
			fixed (byte* preg = reg)
			{
				fixed (byte* pset = set)
				{
					fixed (byte* pbinding = binding)
					{
						CompileOptionsSetHlslRegisterSetAndBindingNative(options, (byte*)preg, (byte*)pset, (byte*)pbinding);
					}
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage,<br/>
		/// but affects all shader stages.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslRegisterSetAndBinding(ShadercCompileOptions options, string reg, string set, string binding)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (reg != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(reg);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(reg, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (set != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(set);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(set, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (binding != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(binding);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(binding, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			CompileOptionsSetHlslRegisterSetAndBindingNative(options, pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets whether the compiler should enable extension<br/>
		/// SPV_GOOGLE_hlsl_functionality1.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetHlslFunctionality1Native(ShadercCompileOptions options, byte enable)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[26])(options, enable);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[26])(options, enable);
			#endif
		}

		/// <summary>
		/// Sets whether the compiler should enable extension<br/>
		/// SPV_GOOGLE_hlsl_functionality1.<br/>
		/// </summary>
		public static void CompileOptionsSetHlslFunctionality1(ShadercCompileOptions options, bool enable)
		{
			CompileOptionsSetHlslFunctionality1Native(options, enable ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets whether 16-bit types are supported in HLSL or not.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetHlsl16BitTypesNative(ShadercCompileOptions options, byte enable)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[27])(options, enable);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[27])(options, enable);
			#endif
		}

		/// <summary>
		/// Sets whether 16-bit types are supported in HLSL or not.<br/>
		/// </summary>
		public static void CompileOptionsSetHlsl16BitTypes(ShadercCompileOptions options, bool enable)
		{
			CompileOptionsSetHlsl16BitTypesNative(options, enable ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Enables or disables relaxed Vulkan rules.<br/>
		/// This allows most OpenGL shaders to compile under Vulkan semantics.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetVulkanRulesRelaxedNative(ShadercCompileOptions options, byte enable)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[28])(options, enable);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[28])(options, enable);
			#endif
		}

		/// <summary>
		/// Enables or disables relaxed Vulkan rules.<br/>
		/// This allows most OpenGL shaders to compile under Vulkan semantics.<br/>
		/// </summary>
		public static void CompileOptionsSetVulkanRulesRelaxed(ShadercCompileOptions options, bool enable)
		{
			CompileOptionsSetVulkanRulesRelaxedNative(options, enable ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets whether the compiler should invert position.Y output in vertex shader.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetInvertYNative(ShadercCompileOptions options, byte enable)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[29])(options, enable);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[29])(options, enable);
			#endif
		}

		/// <summary>
		/// Sets whether the compiler should invert position.Y output in vertex shader.<br/>
		/// </summary>
		public static void CompileOptionsSetInvertY(ShadercCompileOptions options, bool enable)
		{
			CompileOptionsSetInvertYNative(options, enable ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets whether the compiler generates code for max and min builtins which,<br/>
		/// if given a NaN operand, will return the other operand. Similarly, the clamp<br/>
		/// builtin will favour the non-NaN operands, as if clamp were implemented<br/>
		/// as a composition of max and min.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileOptionsSetNanClampNative(ShadercCompileOptions options, byte enable)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[30])(options, enable);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompileOptions, byte, void>)funcTable[30])(options, enable);
			#endif
		}

		/// <summary>
		/// Sets whether the compiler generates code for max and min builtins which,<br/>
		/// if given a NaN operand, will return the other operand. Similarly, the clamp<br/>
		/// builtin will favour the non-NaN operands, as if clamp were implemented<br/>
		/// as a composition of max and min.<br/>
		/// </summary>
		public static void CompileOptionsSetNanClamp(ShadercCompileOptions options, bool enable)
		{
			CompileOptionsSetNanClampNative(options, enable ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ShadercCompilationResult CompileIntoSpvNative(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompiler, byte*, nuint, ShadercShaderKind, byte*, byte*, ShadercCompileOptions, ShadercCompilationResult>)funcTable[31])(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			#else
			return (ShadercCompilationResult)((delegate* unmanaged[Cdecl]<ShadercCompiler, nint, nuint, ShadercShaderKind, nint, nint, ShadercCompileOptions, ShadercCompilationResult>)funcTable[31])(compiler, (nint)sourceText, sourceTextSize, shaderKind, (nint)inputFileName, (nint)entryPointName, additionalOptions);
			#endif
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = CompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			return ret;
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				ShadercCompilationResult ret = CompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				ShadercCompilationResult ret = CompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				ShadercCompilationResult ret = CompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = inputFileName)
			{
				ShadercCompilationResult ret = CompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					ShadercCompilationResult ret = CompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				fixed (byte* pinputFileName = inputFileName)
				{
					ShadercCompilationResult ret = CompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, entryPointName, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = &entryPointName)
			{
				ShadercCompilationResult ret = CompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = entryPointName)
			{
				ShadercCompilationResult ret = CompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (entryPointName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(entryPointName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, pStr0, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				fixed (byte* pentryPointName = entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = inputFileName)
			{
				fixed (byte* pentryPointName = entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					fixed (byte* pentryPointName = &entryPointName)
					{
						ShadercCompilationResult ret = CompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				fixed (byte* pinputFileName = inputFileName)
				{
					fixed (byte* pentryPointName = entryPointName)
					{
						ShadercCompilationResult ret = CompileIntoSpvNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Takes a GLSL source string and the associated shader kind, input file<br/>
		/// name, compiles it according to the given additional_options. If the shader<br/>
		/// kind is not set to a specified kind, but shaderc_glslc_infer_from_source,<br/>
		/// the compiler will try to deduce the shader kind from the source<br/>
		/// string and a failure in deducing will generate an error. Currently only<br/>
		/// #pragma annotation is supported. If the shader kind is set to one of the<br/>
		/// default shader kinds, the compiler will fall back to the default shader<br/>
		/// kind in case it failed to deduce the shader kind from source string.<br/>
		/// The input_file_name is a null-termintated string. It is used as a tag to<br/>
		/// identify the source string in cases like emitting error messages. It<br/>
		/// doesn't have to be a 'file name'.<br/>
		/// The source string will be compiled into SPIR-V binary and a<br/>
		/// shaderc_compilation_result will be returned to hold the results.<br/>
		/// The entry_point_name null-terminated string defines the name of the entry<br/>
		/// point to associate with this GLSL source. If the additional_options<br/>
		/// parameter is not null, then the compilation is modified by any options<br/>
		/// present.  May be safely called from multiple threads without explicit<br/>
		/// synchronization. If there was failure in allocating the compiler object,<br/>
		/// null will be returned.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpv(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (entryPointName != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(entryPointName, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, pStr2, additionalOptions);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ShadercCompilationResult CompileIntoSpvAssemblyNative(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompiler, byte*, nuint, ShadercShaderKind, byte*, byte*, ShadercCompileOptions, ShadercCompilationResult>)funcTable[32])(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			#else
			return (ShadercCompilationResult)((delegate* unmanaged[Cdecl]<ShadercCompiler, nint, nuint, ShadercShaderKind, nint, nint, ShadercCompileOptions, ShadercCompilationResult>)funcTable[32])(compiler, (nint)sourceText, sourceTextSize, shaderKind, (nint)inputFileName, (nint)entryPointName, additionalOptions);
			#endif
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = inputFileName)
			{
				ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				fixed (byte* pinputFileName = inputFileName)
				{
					ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, entryPointName, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = &entryPointName)
			{
				ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = entryPointName)
			{
				ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (entryPointName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(entryPointName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, pStr0, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				fixed (byte* pentryPointName = entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = inputFileName)
			{
				fixed (byte* pentryPointName = entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					fixed (byte* pentryPointName = &entryPointName)
					{
						ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				fixed (byte* pinputFileName = inputFileName)
				{
					fixed (byte* pentryPointName = entryPointName)
					{
						ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text<br/>
		/// instead of a SPIR-V binary module.  The SPIR-V assembly syntax is as defined<br/>
		/// by the SPIRV-Tools open source project.<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoSpvAssembly(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (entryPointName != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(entryPointName, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			ShadercCompilationResult ret = CompileIntoSpvAssemblyNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, pStr2, additionalOptions);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ShadercCompilationResult CompileIntoPreprocessedTextNative(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompiler, byte*, nuint, ShadercShaderKind, byte*, byte*, ShadercCompileOptions, ShadercCompilationResult>)funcTable[33])(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			#else
			return (ShadercCompilationResult)((delegate* unmanaged[Cdecl]<ShadercCompiler, nint, nuint, ShadercShaderKind, nint, nint, ShadercCompileOptions, ShadercCompilationResult>)funcTable[33])(compiler, (nint)sourceText, sourceTextSize, shaderKind, (nint)inputFileName, (nint)entryPointName, additionalOptions);
			#endif
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = inputFileName)
			{
				ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, entryPointName, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				fixed (byte* pinputFileName = inputFileName)
				{
					ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, entryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, byte* entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, entryPointName, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = &entryPointName)
			{
				ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pentryPointName = entryPointName)
			{
				ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (entryPointName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(entryPointName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, inputFileName, pStr0, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				fixed (byte* pentryPointName = entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, inputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, byte* inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, inputFileName, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = &inputFileName)
			{
				fixed (byte* pentryPointName = &entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* pinputFileName = inputFileName)
			{
				fixed (byte* pentryPointName = entryPointName)
				{
					ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
					return ret;
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, byte* sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inputFileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inputFileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (entryPointName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(entryPointName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, sourceText, sourceTextSize, shaderKind, pStr0, pStr1, additionalOptions);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, ref byte sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ref byte inputFileName, ref byte entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = &sourceText)
			{
				fixed (byte* pinputFileName = &inputFileName)
				{
					fixed (byte* pentryPointName = &entryPointName)
					{
						ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, ReadOnlySpan<byte> sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, ReadOnlySpan<byte> inputFileName, ReadOnlySpan<byte> entryPointName, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceText = sourceText)
			{
				fixed (byte* pinputFileName = inputFileName)
				{
					fixed (byte* pentryPointName = entryPointName)
					{
						ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, (byte*)psourceText, sourceTextSize, shaderKind, (byte*)pinputFileName, (byte*)pentryPointName, additionalOptions);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Like shaderc_compile_into_spv, but the result contains preprocessed source<br/>
		/// code instead of a SPIR-V binary module<br/>
		/// </summary>
		public static ShadercCompilationResult CompileIntoPreprocessedText(ShadercCompiler compiler, string sourceText, nuint sourceTextSize, ShadercShaderKind shaderKind, string inputFileName, string entryPointName, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inputFileName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inputFileName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inputFileName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (entryPointName != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(entryPointName);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(entryPointName, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			ShadercCompilationResult ret = CompileIntoPreprocessedTextNative(compiler, pStr0, sourceTextSize, shaderKind, pStr1, pStr2, additionalOptions);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>
		/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>
		/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>
		/// returned to hold the results.<br/>
		/// The assembling will pick options suitable for assembling specified in the<br/>
		/// additional_options parameter.<br/>
		/// May be safely called from multiple threads without explicit synchronization.<br/>
		/// If there was failure in allocating the compiler object, null will be<br/>
		/// returned.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ShadercCompilationResult AssembleIntoSpvNative(ShadercCompiler compiler, byte* sourceAssembly, nuint sourceAssemblySize, ShadercCompileOptions additionalOptions)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompiler, byte*, nuint, ShadercCompileOptions, ShadercCompilationResult>)funcTable[34])(compiler, sourceAssembly, sourceAssemblySize, additionalOptions);
			#else
			return (ShadercCompilationResult)((delegate* unmanaged[Cdecl]<ShadercCompiler, nint, nuint, ShadercCompileOptions, ShadercCompilationResult>)funcTable[34])(compiler, (nint)sourceAssembly, sourceAssemblySize, additionalOptions);
			#endif
		}

		/// <summary>
		/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>
		/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>
		/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>
		/// returned to hold the results.<br/>
		/// The assembling will pick options suitable for assembling specified in the<br/>
		/// additional_options parameter.<br/>
		/// May be safely called from multiple threads without explicit synchronization.<br/>
		/// If there was failure in allocating the compiler object, null will be<br/>
		/// returned.<br/>
		/// </summary>
		public static ShadercCompilationResult AssembleIntoSpv(ShadercCompiler compiler, byte* sourceAssembly, nuint sourceAssemblySize, ShadercCompileOptions additionalOptions)
		{
			ShadercCompilationResult ret = AssembleIntoSpvNative(compiler, sourceAssembly, sourceAssemblySize, additionalOptions);
			return ret;
		}

		/// <summary>
		/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>
		/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>
		/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>
		/// returned to hold the results.<br/>
		/// The assembling will pick options suitable for assembling specified in the<br/>
		/// additional_options parameter.<br/>
		/// May be safely called from multiple threads without explicit synchronization.<br/>
		/// If there was failure in allocating the compiler object, null will be<br/>
		/// returned.<br/>
		/// </summary>
		public static ShadercCompilationResult AssembleIntoSpv(ShadercCompiler compiler, ref byte sourceAssembly, nuint sourceAssemblySize, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceAssembly = &sourceAssembly)
			{
				ShadercCompilationResult ret = AssembleIntoSpvNative(compiler, (byte*)psourceAssembly, sourceAssemblySize, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>
		/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>
		/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>
		/// returned to hold the results.<br/>
		/// The assembling will pick options suitable for assembling specified in the<br/>
		/// additional_options parameter.<br/>
		/// May be safely called from multiple threads without explicit synchronization.<br/>
		/// If there was failure in allocating the compiler object, null will be<br/>
		/// returned.<br/>
		/// </summary>
		public static ShadercCompilationResult AssembleIntoSpv(ShadercCompiler compiler, ReadOnlySpan<byte> sourceAssembly, nuint sourceAssemblySize, ShadercCompileOptions additionalOptions)
		{
			fixed (byte* psourceAssembly = sourceAssembly)
			{
				ShadercCompilationResult ret = AssembleIntoSpvNative(compiler, (byte*)psourceAssembly, sourceAssemblySize, additionalOptions);
				return ret;
			}
		}

		/// <summary>
		/// Takes an assembly string of the format defined in the SPIRV-Tools project<br/>
		/// (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md),<br/>
		/// assembles it into SPIR-V binary and a shaderc_compilation_result will be<br/>
		/// returned to hold the results.<br/>
		/// The assembling will pick options suitable for assembling specified in the<br/>
		/// additional_options parameter.<br/>
		/// May be safely called from multiple threads without explicit synchronization.<br/>
		/// If there was failure in allocating the compiler object, null will be<br/>
		/// returned.<br/>
		/// </summary>
		public static ShadercCompilationResult AssembleIntoSpv(ShadercCompiler compiler, string sourceAssembly, nuint sourceAssemblySize, ShadercCompileOptions additionalOptions)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sourceAssembly != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sourceAssembly);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sourceAssembly, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShadercCompilationResult ret = AssembleIntoSpvNative(compiler, pStr0, sourceAssemblySize, additionalOptions);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Releases the resources held by the result object. It is invalid to use the<br/>
		/// result object for any further operations.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResultReleaseNative(ShadercCompilationResult result)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ShadercCompilationResult, void>)funcTable[35])(result);
			#else
			((delegate* unmanaged[Cdecl]<ShadercCompilationResult, void>)funcTable[35])(result);
			#endif
		}

		/// <summary>
		/// Releases the resources held by the result object. It is invalid to use the<br/>
		/// result object for any further operations.<br/>
		/// </summary>
		public static void ResultRelease(ShadercCompilationResult result)
		{
			ResultReleaseNative(result);
		}

		/// <summary>
		/// Returns the number of bytes of the compilation output data in a result<br/>
		/// object.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint ResultGetLengthNative(ShadercCompilationResult result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompilationResult, nuint>)funcTable[36])(result);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<ShadercCompilationResult, nuint>)funcTable[36])(result);
			#endif
		}

		/// <summary>
		/// Returns the number of bytes of the compilation output data in a result<br/>
		/// object.<br/>
		/// </summary>
		public static nuint ResultGetLength(ShadercCompilationResult result)
		{
			nuint ret = ResultGetLengthNative(result);
			return ret;
		}

		/// <summary>
		/// Returns the number of warnings generated during the compilation.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint ResultGetNumWarningsNative(ShadercCompilationResult result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompilationResult, nuint>)funcTable[37])(result);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<ShadercCompilationResult, nuint>)funcTable[37])(result);
			#endif
		}

		/// <summary>
		/// Returns the number of warnings generated during the compilation.<br/>
		/// </summary>
		public static nuint ResultGetNumWarnings(ShadercCompilationResult result)
		{
			nuint ret = ResultGetNumWarningsNative(result);
			return ret;
		}

		/// <summary>
		/// Returns the number of errors generated during the compilation.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint ResultGetNumErrorsNative(ShadercCompilationResult result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompilationResult, nuint>)funcTable[38])(result);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<ShadercCompilationResult, nuint>)funcTable[38])(result);
			#endif
		}

		/// <summary>
		/// Returns the number of errors generated during the compilation.<br/>
		/// </summary>
		public static nuint ResultGetNumErrors(ShadercCompilationResult result)
		{
			nuint ret = ResultGetNumErrorsNative(result);
			return ret;
		}

		/// <summary>
		/// Returns the compilation status, indicating whether the compilation succeeded,<br/>
		/// or failed due to some reasons, like invalid shader stage or compilation<br/>
		/// errors.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ShadercCompilationStatus ResultGetCompilationStatusNative(ShadercCompilationResult unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompilationResult, ShadercCompilationStatus>)funcTable[39])(unknown0);
			#else
			return (ShadercCompilationStatus)((delegate* unmanaged[Cdecl]<ShadercCompilationResult, ShadercCompilationStatus>)funcTable[39])(unknown0);
			#endif
		}

		/// <summary>
		/// Returns the compilation status, indicating whether the compilation succeeded,<br/>
		/// or failed due to some reasons, like invalid shader stage or compilation<br/>
		/// errors.<br/>
		/// </summary>
		public static ShadercCompilationStatus ResultGetCompilationStatus(ShadercCompilationResult unknown0)
		{
			ShadercCompilationStatus ret = ResultGetCompilationStatusNative(unknown0);
			return ret;
		}

		/// <summary>
		/// Returns a pointer to the start of the compilation output data bytes, either<br/>
		/// SPIR-V binary or char string. When the source string is compiled into SPIR-V<br/>
		/// binary, this is guaranteed to be castable to a uint32_t*. If the result<br/>
		/// contains assembly text or preprocessed source text, the pointer will point to<br/>
		/// the resulting array of characters.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ResultGetBytesNative(ShadercCompilationResult result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompilationResult, byte*>)funcTable[40])(result);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<ShadercCompilationResult, nint>)funcTable[40])(result);
			#endif
		}

		/// <summary>
		/// Returns a pointer to the start of the compilation output data bytes, either<br/>
		/// SPIR-V binary or char string. When the source string is compiled into SPIR-V<br/>
		/// binary, this is guaranteed to be castable to a uint32_t*. If the result<br/>
		/// contains assembly text or preprocessed source text, the pointer will point to<br/>
		/// the resulting array of characters.<br/>
		/// </summary>
		public static byte* ResultGetBytes(ShadercCompilationResult result)
		{
			byte* ret = ResultGetBytesNative(result);
			return ret;
		}

		/// <summary>
		/// Returns a pointer to the start of the compilation output data bytes, either<br/>
		/// SPIR-V binary or char string. When the source string is compiled into SPIR-V<br/>
		/// binary, this is guaranteed to be castable to a uint32_t*. If the result<br/>
		/// contains assembly text or preprocessed source text, the pointer will point to<br/>
		/// the resulting array of characters.<br/>
		/// </summary>
		public static string ResultGetBytesS(ShadercCompilationResult result)
		{
			string ret = Utils.DecodeStringUTF8(ResultGetBytesNative(result));
			return ret;
		}

		/// <summary>
		/// Returns a null-terminated string that contains any error messages generated<br/>
		/// during the compilation.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ResultGetErrorMessageNative(ShadercCompilationResult result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ShadercCompilationResult, byte*>)funcTable[41])(result);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<ShadercCompilationResult, nint>)funcTable[41])(result);
			#endif
		}

		/// <summary>
		/// Returns a null-terminated string that contains any error messages generated<br/>
		/// during the compilation.<br/>
		/// </summary>
		public static byte* ResultGetErrorMessage(ShadercCompilationResult result)
		{
			byte* ret = ResultGetErrorMessageNative(result);
			return ret;
		}

		/// <summary>
		/// Returns a null-terminated string that contains any error messages generated<br/>
		/// during the compilation.<br/>
		/// </summary>
		public static string ResultGetErrorMessageS(ShadercCompilationResult result)
		{
			string ret = Utils.DecodeStringUTF8(ResultGetErrorMessageNative(result));
			return ret;
		}

		/// <summary>
		/// Provides the version <br/>
		/// &<br/>
		/// revision of the SPIR-V which will be produced<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSpvVersionNative(uint* version, uint* revision)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, uint*, void>)funcTable[42])(version, revision);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[42])((nint)version, (nint)revision);
			#endif
		}

		/// <summary>
		/// Provides the version <br/>
		/// &<br/>
		/// revision of the SPIR-V which will be produced<br/>
		/// </summary>
		public static void GetSpvVersion(uint* version, uint* revision)
		{
			GetSpvVersionNative(version, revision);
		}

		/// <summary>
		/// Provides the version <br/>
		/// &<br/>
		/// revision of the SPIR-V which will be produced<br/>
		/// </summary>
		public static void GetSpvVersion(ref uint version, uint* revision)
		{
			fixed (uint* pversion = &version)
			{
				GetSpvVersionNative((uint*)pversion, revision);
			}
		}

		/// <summary>
		/// Provides the version <br/>
		/// &<br/>
		/// revision of the SPIR-V which will be produced<br/>
		/// </summary>
		public static void GetSpvVersion(uint* version, ref uint revision)
		{
			fixed (uint* prevision = &revision)
			{
				GetSpvVersionNative(version, (uint*)prevision);
			}
		}

		/// <summary>
		/// Provides the version <br/>
		/// &<br/>
		/// revision of the SPIR-V which will be produced<br/>
		/// </summary>
		public static void GetSpvVersion(ref uint version, ref uint revision)
		{
			fixed (uint* pversion = &version)
			{
				fixed (uint* prevision = &revision)
				{
					GetSpvVersionNative((uint*)pversion, (uint*)prevision);
				}
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ParseVersionProfileNative(byte* str, int* version, ShadercProfile* profile)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int*, ShadercProfile*, byte>)funcTable[43])(str, version, profile);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[43])((nint)str, (nint)version, (nint)profile);
			#endif
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(byte* str, int* version, ShadercProfile* profile)
		{
			byte ret = ParseVersionProfileNative(str, version, profile);
			return ret != 0;
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(ref byte str, int* version, ShadercProfile* profile)
		{
			fixed (byte* pstr = &str)
			{
				byte ret = ParseVersionProfileNative((byte*)pstr, version, profile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(ReadOnlySpan<byte> str, int* version, ShadercProfile* profile)
		{
			fixed (byte* pstr = str)
			{
				byte ret = ParseVersionProfileNative((byte*)pstr, version, profile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(string str, int* version, ShadercProfile* profile)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ParseVersionProfileNative(pStr0, version, profile);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(byte* str, ref int version, ShadercProfile* profile)
		{
			fixed (int* pversion = &version)
			{
				byte ret = ParseVersionProfileNative(str, (int*)pversion, profile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(ref byte str, ref int version, ShadercProfile* profile)
		{
			fixed (byte* pstr = &str)
			{
				fixed (int* pversion = &version)
				{
					byte ret = ParseVersionProfileNative((byte*)pstr, (int*)pversion, profile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(ReadOnlySpan<byte> str, ref int version, ShadercProfile* profile)
		{
			fixed (byte* pstr = str)
			{
				fixed (int* pversion = &version)
				{
					byte ret = ParseVersionProfileNative((byte*)pstr, (int*)pversion, profile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(string str, ref int version, ShadercProfile* profile)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pversion = &version)
			{
				byte ret = ParseVersionProfileNative(pStr0, (int*)pversion, profile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(byte* str, int* version, ref ShadercProfile profile)
		{
			fixed (ShadercProfile* pprofile = &profile)
			{
				byte ret = ParseVersionProfileNative(str, version, (ShadercProfile*)pprofile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(ref byte str, int* version, ref ShadercProfile profile)
		{
			fixed (byte* pstr = &str)
			{
				fixed (ShadercProfile* pprofile = &profile)
				{
					byte ret = ParseVersionProfileNative((byte*)pstr, version, (ShadercProfile*)pprofile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(ReadOnlySpan<byte> str, int* version, ref ShadercProfile profile)
		{
			fixed (byte* pstr = str)
			{
				fixed (ShadercProfile* pprofile = &profile)
				{
					byte ret = ParseVersionProfileNative((byte*)pstr, version, (ShadercProfile*)pprofile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(string str, int* version, ref ShadercProfile profile)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ShadercProfile* pprofile = &profile)
			{
				byte ret = ParseVersionProfileNative(pStr0, version, (ShadercProfile*)pprofile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(byte* str, ref int version, ref ShadercProfile profile)
		{
			fixed (int* pversion = &version)
			{
				fixed (ShadercProfile* pprofile = &profile)
				{
					byte ret = ParseVersionProfileNative(str, (int*)pversion, (ShadercProfile*)pprofile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(ref byte str, ref int version, ref ShadercProfile profile)
		{
			fixed (byte* pstr = &str)
			{
				fixed (int* pversion = &version)
				{
					fixed (ShadercProfile* pprofile = &profile)
					{
						byte ret = ParseVersionProfileNative((byte*)pstr, (int*)pversion, (ShadercProfile*)pprofile);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(ReadOnlySpan<byte> str, ref int version, ref ShadercProfile profile)
		{
			fixed (byte* pstr = str)
			{
				fixed (int* pversion = &version)
				{
					fixed (ShadercProfile* pprofile = &profile)
					{
						byte ret = ParseVersionProfileNative((byte*)pstr, (int*)pversion, (ShadercProfile*)pprofile);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Parses the version and profile from a given null-terminated string<br/>
		/// containing both version and profile, like: '450core'. Returns false if<br/>
		/// the string can not be parsed. Returns true when the parsing succeeds. The<br/>
		/// parsed version and profile are returned through arguments.<br/>
		/// </summary>
		public static bool ParseVersionProfile(string str, ref int version, ref ShadercProfile profile)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pversion = &version)
			{
				fixed (ShadercProfile* pprofile = &profile)
				{
					byte ret = ParseVersionProfileNative(pStr0, (int*)pversion, (ShadercProfile*)pprofile);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

	}
}
