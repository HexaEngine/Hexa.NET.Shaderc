// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;

namespace HexaEngine.Shaderc
{
	/// <summary>
	/// A dispatchable handle.
	/// </summary>
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct ShadercCompilerT : IEquatable<ShadercCompilerT>
	{
		public ShadercCompilerT(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static ShadercCompilerT Null => new ShadercCompilerT(0);
		public static implicit operator ShadercCompilerT(nint handle) => new ShadercCompilerT(handle);
		public static bool operator ==(ShadercCompilerT left, ShadercCompilerT right) => left.Handle == right.Handle;
		public static bool operator !=(ShadercCompilerT left, ShadercCompilerT right) => left.Handle != right.Handle;
		public static bool operator ==(ShadercCompilerT left, nint right) => left.Handle == right;
		public static bool operator !=(ShadercCompilerT left, nint right) => left.Handle != right;
		public bool Equals(ShadercCompilerT other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ShadercCompilerT handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("ShadercCompilerT [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// A dispatchable handle.
	/// </summary>
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct ShadercCompileOptionsT : IEquatable<ShadercCompileOptionsT>
	{
		public ShadercCompileOptionsT(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static ShadercCompileOptionsT Null => new ShadercCompileOptionsT(0);
		public static implicit operator ShadercCompileOptionsT(nint handle) => new ShadercCompileOptionsT(handle);
		public static bool operator ==(ShadercCompileOptionsT left, ShadercCompileOptionsT right) => left.Handle == right.Handle;
		public static bool operator !=(ShadercCompileOptionsT left, ShadercCompileOptionsT right) => left.Handle != right.Handle;
		public static bool operator ==(ShadercCompileOptionsT left, nint right) => left.Handle == right;
		public static bool operator !=(ShadercCompileOptionsT left, nint right) => left.Handle != right;
		public bool Equals(ShadercCompileOptionsT other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ShadercCompileOptionsT handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("ShadercCompileOptionsT [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// A dispatchable handle.
	/// </summary>
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct ShadercIncludeResolveFn : IEquatable<ShadercIncludeResolveFn>
	{
		public ShadercIncludeResolveFn(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static ShadercIncludeResolveFn Null => new ShadercIncludeResolveFn(0);
		public static implicit operator ShadercIncludeResolveFn(nint handle) => new ShadercIncludeResolveFn(handle);
		public static bool operator ==(ShadercIncludeResolveFn left, ShadercIncludeResolveFn right) => left.Handle == right.Handle;
		public static bool operator !=(ShadercIncludeResolveFn left, ShadercIncludeResolveFn right) => left.Handle != right.Handle;
		public static bool operator ==(ShadercIncludeResolveFn left, nint right) => left.Handle == right;
		public static bool operator !=(ShadercIncludeResolveFn left, nint right) => left.Handle != right;
		public bool Equals(ShadercIncludeResolveFn other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ShadercIncludeResolveFn handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("ShadercIncludeResolveFn [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// A dispatchable handle.
	/// </summary>
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct ShadercIncludeResultReleaseFn : IEquatable<ShadercIncludeResultReleaseFn>
	{
		public ShadercIncludeResultReleaseFn(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static ShadercIncludeResultReleaseFn Null => new ShadercIncludeResultReleaseFn(0);
		public static implicit operator ShadercIncludeResultReleaseFn(nint handle) => new ShadercIncludeResultReleaseFn(handle);
		public static bool operator ==(ShadercIncludeResultReleaseFn left, ShadercIncludeResultReleaseFn right) => left.Handle == right.Handle;
		public static bool operator !=(ShadercIncludeResultReleaseFn left, ShadercIncludeResultReleaseFn right) => left.Handle != right.Handle;
		public static bool operator ==(ShadercIncludeResultReleaseFn left, nint right) => left.Handle == right;
		public static bool operator !=(ShadercIncludeResultReleaseFn left, nint right) => left.Handle != right;
		public bool Equals(ShadercIncludeResultReleaseFn other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ShadercIncludeResultReleaseFn handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("ShadercIncludeResultReleaseFn [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// A dispatchable handle.
	/// </summary>
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct ShadercCompilationResultT : IEquatable<ShadercCompilationResultT>
	{
		public ShadercCompilationResultT(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static ShadercCompilationResultT Null => new ShadercCompilationResultT(0);
		public static implicit operator ShadercCompilationResultT(nint handle) => new ShadercCompilationResultT(handle);
		public static bool operator ==(ShadercCompilationResultT left, ShadercCompilationResultT right) => left.Handle == right.Handle;
		public static bool operator !=(ShadercCompilationResultT left, ShadercCompilationResultT right) => left.Handle != right.Handle;
		public static bool operator ==(ShadercCompilationResultT left, nint right) => left.Handle == right;
		public static bool operator !=(ShadercCompilationResultT left, nint right) => left.Handle != right;
		public bool Equals(ShadercCompilationResultT other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ShadercCompilationResultT handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("ShadercCompilationResultT [0x{0}]", Handle.ToString("X"));
	}

}
